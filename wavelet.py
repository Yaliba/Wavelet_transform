# -*- coding: utf-8 -*-
"""Wavelet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZzTkL-lILbnpE6wccfR8aKsPoR0LmEyp
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import math as math
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import matplotlib.colors as colors
import cmath
import pywt
import scipy.io
from os import listdir
from sklearn import svm,datasets,linear_model

!pip install umap-learn
!pip install umap-learn[plot]
!pip install holoviews
import umap.umap_ as umap
import umap.plot

#####   get_file   #####
# input is file path
# output is mat file data  

def get_file(path):
  profs=scipy.io.loadmat(path)
  return profs

#####   fix_shape   #####
# input is mat file data
# output is an array representing the normalized surface (min is set to zero)
# in addition, surface max value and surface min value 

def fix_shape(profs):
  surf = profs["SOURCE"]
  surf = surf.T
  l = len(surf)
  surf = surf.reshape(l,-1)
  surf_min = np.min(surf)
  surf_max = np.max(surf)
  surf = surf-surf_min
  ### Print surface image ###
  # fig = plt.figure(figsize=(12,12))
  # plt.imshow(surf, aspect=1)
  # plt.colorbar()
  ###
  return surf, surf_min, surf_max

#####   delete_lowpass   #####
# Accepts: 
# del_levels - how many levels to erase. -1 is full analysis, 0 removes the base level and so on.
# coeff_arr, coeff_slices - outputs of the wavelet decomposition
# return an index matrix that removes the selected levels

def delete_lowpass(del_levels, coeff_arr, coeff_slices):
  ind_test = np.ones(coeff_arr.shape, dtype=bool)
  if del_levels == -1:
    return ind_test
  else:
    dim = [0, 0]
    dim[0] = dim[0] + coeff_arr[coeff_slices[0]].shape[0]
    dim[1] = dim[1] + coeff_arr[coeff_slices[0]].shape[1]
    for i in range(1, del_levels+1):
      dim[0] = dim[0] + coeff_arr[coeff_slices[i]['dd']].shape[0]
      dim[1] = dim[1] + coeff_arr[coeff_slices[i]['dd']].shape[1]
    ind_test[0:dim[0], 0:dim[1]] = 0
    return ind_test, dim

##### wave_trans #####
# Performs wavelet decomposition
# Accepts the surface, the wanted wavelet shape and the amount of
# levels to delete using delete_lowpass
# returns:
  # keep - feature vector
  # boom - reconstructed surface
  # cfilt - 

def wave_trans(surf, wave_shape, del_levels):
  coeffs = pywt.wavedec2(surf, wave_shape, level=10)                        #Perform wavelet transform
  coeff_arr, coeff_slices = pywt.coeffs_to_array(coeffs)                    #Rearrange
  ind_test, dimm = delete_lowpass(del_levels, coeff_arr, coeff_slices)
  cfilt = ind_test * coeff_arr
  csort = np.sort(np.abs(cfilt.reshape(-1)))                                #Sort by most significant min to max
  csort = np.flip(csort)                                                    #Flip order, max to min
  t_index = 1499                                                            #Keep 1500 features - largest values
  thresh=csort[t_index]
  ind1 = np.abs(coeff_arr) >= thresh
  cfilt = ind1 * cfilt
  ind = ind_test & ind1
  nonz=np.count_nonzero(cfilt)
  coeffs_filt = pywt.array_to_coeffs(cfilt,coeff_slices,output_format='wavedec2')
  boom = pywt.waverec2(coeffs_filt, wave_shape)                           #Reconstruct if needed
  keep = list(np.where(ind==1))
  keep_value = cfilt[keep]
  keep.append(keep_value)
  keep = np.transpose(np.array(keep))
  return keep, boom, cfilt

def plotter(cfilt, boom):
  norm = colors.TwoSlopeNorm(vmin=np.min(cfilt), vcenter=0, vmax=np.max(cfilt))

  asp = cfilt.shape[1]//cfilt.shape[0]
  fig = plt.figure(figsize=(12,12))
  plt.imshow(boom,aspect=asp)
  # plt.imshow(cfilt,aspect=asp, cmap='bwr', norm=norm)
  plt.colorbar()

  # fig = plt.figure(figsize=(12,12))
  # plt.imshow(cfilt,aspect=asp, cmap='bwr', norm=norm)
  # plt.colorbar()    

########################################################################
########################################################################

wave_shape = 'bior3.3'
del_levels = 1                                                            # value of 0 removes the base level lowpass. If full recons is needed use -1
tester = 11
directory = "/content/drive/MyDrive/Technion/MSc/Data/Profiles"
files = listdir(directory)
files.remove('old')
prediction_surf = get_file(directory+'/'+files[tester])
print(directory+'/'+files[tester])
# files.remove(files[tester])
results = []
classify = []

for i in range(0, len(files)):
  file_path = files[i]
  if (file_path[len(file_path)-11] == 'f'):
    classify.append(2)
  else:
    if (file_path[len(file_path)-10] == 's'):
      classify.append(1)
    else:
      classify.append(3)
  profs = get_file(directory+'/'+file_path)
  # profs = get_file('/content/drive/MyDrive/Technion/MSc/Data/DEN Fractography/afterSES/060817/DEN_212U/Right/full_surf_212R_fs_orig.mat')
  surf,surf_min,surf_max = fix_shape(profs)
  keep, boom, cfilt = wave_trans(surf, wave_shape, del_levels)
  # plotter(cfilt,boom)
  results.append(keep)

rere = []
for i in range(0, len(files)):
  rere.append(results[i].reshape(1,4500))
rere = np.array(rere).reshape(len(files),4500)
# clf = svm.SVC()
clf = linear_model.Lasso(alpha=0.1)
clf.fit(rere, classify)


surf,surf_min,surf_max = fix_shape(prediction_surf)
keep, boom, cfilt = wave_trans(surf, wave_shape, del_levels)
clf.predict(keep.reshape(1,4500))

mapper = umap.UMAP().fit(rere)
umap.plot.points(mapper)

cD1[1].shape

# coeffs_filt = pywt.array_to_coeffs(coeff_arr,coeff_slices[1],output_format='wavedec2')
boom = pywt.waverec2([cA], 'db2')
plt.show()
plt.imshow(boom,aspect='auto',cmap='gray')
boom1 = pywt.waverec2([cA,cD1], 'db2')
plt.show()
plt.imshow(boom1,aspect='auto',cmap='gray')
boom2 = pywt.waverec2([cA,cD1,cD2], 'db2')
plt.show()
plt.imshow(boom2,aspect='auto',cmap='gray')

import pandas as pd
df1 = pd.DataFrame(ww)

df1.head()

df1.describe()

df1.boxplot()

fig = plt.figure(figsize=(18,6))
axs = fig.subplots(1,3)
lvl = 3
axs[0].imshow(coeffs[lvl][0],aspect='auto',cmap='bwr')
axs[1].imshow(coeffs[lvl][1],aspect='auto',cmap='bwr')
axs[2].imshow(coeffs[lvl][2],aspect='auto',cmap='bwr')
# plt.colorbar()
# # plt.show()
# # plt.imshow(cD1[1],aspect='auto')
# # plt.show()
# # plt.imshow(cD1[2],aspect='auto')
# plt.show()
# plt.imshow(surf,aspect='auto')